% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/de.R
\name{mml}
\alias{mml}
\title{Marginal Maximum Likelihood Estimation of Linear Models}
\usage{
mml(formula, stuItems, stuDat, paramTab, Q = 30, polyModel = c("GPCM",
  "GRM"), regType = c("regression", "popMean"), weightvar = NULL,
  control = list(), idVar = c(), missingCode = 8,
  missingValue = "c", multiCore = FALSE, bobyqaControl = list)
}
\arguments{
\item{formula}{a formula object in the style of \code{lm}}

\item{stuItems}{a list where each element is named a student ID and contains
a \code{data.frame}; see Details for the format}

\item{stuDat}{a \code{data.frame} with a single row per student. Predictors in
the formula must be in \code{stuDat}.}

\item{paramTab}{a \code{data.frame} with columns shown in Details}

\item{Q}{the number of integration points}

\item{polyModel}{polytomous response model;
one of \code{GPCM} for the Graded Partial Credit Model
or \code{GRM} for the Graded Response Model}

\item{regType}{one of \code{regression} or \code{popMean} where the latter
estimates a population level mean}

\item{weightvar}{a variable name on \code{stuDat} that is the full sample weight}

\item{control}{a list with four elements that control the fitting process. See Details.}

\item{idVar}{a variable name on \code{stuDat} that is the identifier. Every 
ID from \code{stuDat} must appear on \code{stuItems} and vice versa.}

\item{missingCode}{the value a score is set to that indicates the item is missing.
An item scored as \code{NA} will be ignored. The \code{missingCode}
argument allows the user to recode scores to \code{missingValue}.
This argument applies exclusively to binomial items.}

\item{missingValue}{the value to set items scored as \code{missingCode}.
When set to a number, that value is used for all items.
When set to \dQuote{\code{C}}, then the guessing parameter
is used.}

\item{multiCore}{allows the \code{foreach} package to be used. You should
                 have already called 
\ifelse{latex}{the \code{registerDoParallel} function in the \code{doParallel} package}{\code{\link[doParallel]{registerDoParallel}}}.}

\item{bobyqaControl}{a list that gets passed to \ifelse{latex}{the \code{bobyqa} optimizer in \code{minqa}}{\code{\link[minqa]{bobyqa}}}}
}
\value{
object of class \code{mml.means}. 
This is a list with elements: 
\item{call}{the call used to generate this \code{mml.means} object}
\item{coefficients}{the marginal maximum likelihood regression coefficients, including the estimated residual standard error}
\item{LogLik}{the log-likelihood of the fit model}
\item{X}{the design matrix of the marginal maximum likelihood regression}
\item{Convergence}{a convergence note from the \code{bobyqa} optimizer}
\item{location}{used for scaling the estimates}
\item{scale}{used for scaling the estimates}
\item{lnlf}{the likelihood function} 
\item{rr1}{the density function of each individual, conditional only on item responses in \code{stuItems}}
\item{stuDat}{the \code{stuDat} argument}
\item{weightvar}{the weight variable}
\item{nodes}{the nodes the likelihood was evaluated on}
\item{iterations}{the number of iterations required to reach convergence}
\item{obs}{the number of observations used}
}
\description{
Implements a survey-weighted marginal maximum estimation, a type of
regression where the outcome is a latent trait (such as student ability.
Instead of using an estimate, the likelihood function marginalizes student
ability. Includes a variety of variance estimation strategies.
}
\details{
The \code{mml} function models a latent outcome conditioning on student
item response data, student covariate data, and item parameter information;
these three parts are broken up into three arguments.
Student item response data go into \code{stuItems}, whereas student
covariates, weights, and sampling information go into \code{stuDat}.
The \code{paramTab}
contains item parameter information for each item---the result of a
separate item parameter scaling. In the case of 
the National Assessment of Educational Progress (NAEP),
they can be found online, for example, at
\href{https://nces.ed.gov/nationsreportcard/tdw/analysis/scaling_irt.aspx}{https://nces.ed.gov/nationsreportcard/tdw/analysis/scaling_irt.aspx}.
The model for dichotomous responses data is by default three Parameter Logit
(3PL), unless the item parameter information provided by users suggests
otherwise. For example, if the scaling used a two Parameter Logit (2PL) model,
then the guessing parameter can simply be set to zero. For polytomous
responses data, the model is dictated by the \code{polyModel} argument.

Student data are broken up into two parts. The item response data goes
into \code{stuItems} ,and the student covariates for the formula go into
\code{stuDat}. Information about items, such as item difficulties, is in 
\code{paramTab}. All dichotomous items are assumed to be 
3PL, though by setting the guessing parameter to zero, the user
can use a 2PL or the one Parameter Logit (1PL) or Rasch models.
The model for polytomous responses data is dictated by the \code{polyModel}
argument.

The marginal maximum likelihood then integrates the product of the student
ability from the assessment data, and the estimate from the linear model
estimates each student's ability based on the \code{formula} provided
and a residual standard error term. This integration happens from the
minimum node to the maximum node in the \code{control} argument (described
later in this section) with \code{Q} quadrature points. 

The \code{stuItems} argument has the scored student data. It is a list where
each element is named with student ID and contains
a \code{data.frame} with at least two columns.
The first required column is named
\code{key} and shows the item name as it appears in \code{paramTab};
the second column in named
\code{score} and shows the score for that item. For binomial
items, the \code{score} is 0 or 1. For \code{GPCM} items, the scores
start at zero as well. For \code{GRM}, the scores start at 1.

The \code{paramTab} argument is a \code{data.frame} with a column named
\code{ItemID} that agrees with
the \code{key} column in the \code{stuItems} argument,
and, for  a 3PL item, columns \code{P0},
\code{P1}, and \code{P2} for the \dQuote{a}, \dQuote{d}, and
\dQuote{g} parameters, respectively; see the vignette for details of
the 3PL model.
For a \code{GPCM} model, \code{P0} is the \dQuote{a} parameter, and the other 
columns are the \dQuote{d} parameters; see the vignette for details
of the GPCM model.

The \code{control} argument is a list with, optional, items \code{D}, the
scale parameter, that defaults to 1.7; \code{startVal}, which is the starting
value for the coefficients; and \code{min.node} and \code{max.node}, which
sets the range of nodes for all students; these default to
-4 and 4, respectively. The quadrature points then are a range
from \code{min.node} to \code{max.node} with a total of \code{Q} nodes.
}
\examples{
\dontrun{
# get NAEP Primer data
require(EdSurvey)

# data
sdf <- readNAEP(system.file("extdata/data", "M36NT2PM.dat", package = "NAEPprimer"))
cols <- c("m066401", "m093701", "m086001", "m051901", "m067801", "m046501",
          "origwt", "repgrp1", "jkunit", "dsex")
data <- getData(sdf, varnames=cols, addAttributes=TRUE,
                omittedLevels=FALSE, defaultConditions=FALSE,
                returnJKreplicates=FALSE)

# 3PL items only:
# P0 is the discrimination parameter (a),
# P1 is the item difficulty (d),
# P2 is the guessing parameter (g) 
# polytomous responses could use P3-P10 for more difficulties
paramTab <- structure(list(ItemID = c("m066401", "m093701", "m086001",
                                      "m051901", "m067801", "m046501"),
                           P0 = c(0.68, 1.22, 1.05, 1.6, 0.86, 1.03),
                           P1 = c(-0.33, 1.81, 1, 0.61, -1.61, -0.14),
                           P2 = c(0.15, 0.17, 0.22, 0.08, 0.06, 0.37),
                           P3 = c(NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_),
                           P4 = c(NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_),
                           P5 = c(NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_),
                           P6 = c(NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_),
                           P7 = c(NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_),
                           P8 = c(NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_),
                           P9 = c(NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_),
                           P10 = c(NA_real_, NA_real_, NA_real_, NA_real_, NA_real_, NA_real_),
                           ScorePoints = c(1, 1, 1, 1, 1, 1),
                           MODEL = c("3pl", "3pl", "3pl", "3pl", "3pl", "3pl")),
                      row.names = c(1L, 3L, 4L, 5L, 9L, 13L),
                      class = "data.frame", location = 277.1563, scale = 37.7297)
# scores an item as correct if it contains an asterisk and as skipped if it
# is "Omitted", "Not Reached", or "Multiple". The value NA is left as NA.
# this score function is intended to be simple not reflect typical NAEP scoring.
simpleScore <- function(col) {
  score0 <- 0+grepl("*", col, fixed=TRUE)
  score1 <- ifelse(col \%in\% c("Omitted", "Not Reached", "Multiple"), 8, score0)
  score2 <- ifelse(col \%in\% NA, NA, score1)
  return(score2)
}

# score each item in paramTab
for(name in paramTab$ItemID){
  # show score output vs input data
  print(table(sdf[,name], simpleScore(sdf[,name]), useNA="ifany"))
  # score item
  data[,name] <- simpleScore(data[,name])  
}

# make stuItems 
data$id <- 1:nrow(data)
# first make a long data.frame of the item score data
stuItems <- reshape(data=data, varying=c(paramTab$ItemID), idvar=c("id"),
                    direction="long", v.names="score", times=paramTab$ItemID,
                    timevar="key")[,c("id", "key", "score")]
# then break it up into a single data.frame per student
stuItems <- split(stuItems, "id")

# Studat is the student covariates, weights, and sampling information
# used for variance estimation
stuDat <- data[, c('origwt', 'repgrp1', 'jkunit', 'dsex', 'id')]

### MML call 
mml1 <- mml(~dsex, stuItems=stuItems, 
            stuDat=stuDat, paramTab=paramTab, 
            regType = 'regression', Q=34, idVar="id", weightvar = "origwt")

# summary, assumes the sample was drawn IID
summary(mml1)
# summary, accounts for correlation between students in the same schools
summary(mml1, varType="Taylor", stratavar="repgrp1", psuvar="jkunit")
}
}
\author{
Harold Doran, Paul Bailey, Claire Kelley, and Sun-joo Lee
}
